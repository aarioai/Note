# Makefile
Linux/Unix 通常使用 `make` 自动编译代码，特别是 kubernetes 等微服务架构的自动编译。

需求：将文件 a.txt 和 b.txt 合并为 m.txt，将合并后的 m.txt 与 b.txt 再合并一次，并独立使用命令删掉 m.txt。
```makefile
# 定义临时变量
NAME=
PATH=$(shell pwd)
VERSION=v$(shell date +"%Y.%m.%d-%H.%M.%S")

# 依赖 m.txt，但是 m.txt 还不存在，因此需要声明一下以来
x.txt: m.txt b.txt
	cat m.txt b.txt > x.txt
m.txt:
	cat a.txt b.txt > m.txt
# 这里 clean 会被视为文件名（不存在也无所谓）
clean:
	@echo "name: $(NAME)"
	@echo "version: $(VERSION)"
	rm m.txt
	rm x.txt
	cd .. && cd -
```

执行 make clean 删除 m.txt，这里会把 `clean` 当作一个文件，如果 `clean` 文件不存在，则能正常删除。
如果创建一个空 `clean` 文件，则就不会执行该命令了。

因此，可以使用 `.PHONY: xxx` 标识不视为文件。
```makefile
NAME=
PATH=$(shell pwd)
VERSION=v$(shell date +"%Y.%m.%d-%H.%M.%S")

# 依赖 m.txt，但是 m.txt 还不存在，因此需要声明一下以来
x.txt: m.txt b.txt
	cat m.txt b.txt > x.txt
m.txt:
	cat a.txt b.txt > m.txt

# .PHONY: clean 标识env 和 clean不再被视为文件名，也可以分开标识
.PHONY: env clean
env:
    @echo "name: $(NAME)"
	@echo "version: $(VERSION)"
clean:
    # @ 标识不会将改行命令输出到日志
    # - 标识该命令忽略错误，继续执行下面
	@-rm m.txt
	@-rm -f x.txt
	# 合并命令，只能隐藏第一个命令。其他命令输出需要使用  `> /dev/null`
	@cd .. && cd - > /dev/null

.PHONY: bye
bye:
	@echo "bye"
```

执行 `make clean NAME=xxx`